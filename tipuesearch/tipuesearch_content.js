var tipuesearch = {"pages":[{"title":" stdlib_string ","text":"stdlib_string Developer Info fortran-lang/stdlib contributors","tags":"home","loc":"index.html"},{"title":"stdlib_string_type.f90 â€“ stdlib_string","text":"Contents Modules stdlib_string_type Source Code stdlib_string_type.f90 Source Code ! SPDX-Identifier: MIT !> Implementation of a string type to hold an arbitrary sequence of characters. !> !> This module provides string type compatible with all Fortran instrinsic character !> procedures as well as overloaded operators for working with character variables. !> !> A string type can be easily constructed by creating a new instance from a !> character variable or literal by invoking its constructor or by assigning it !> to a string type. Generally, the string type behaves similar to a deferred !> length character in most regards but adds memory access safety. !> !> The specification of this module is available [here](../page/specs/stdlib_string_type.html). module stdlib_string_type implicit none private public :: string_type public :: len , len_trim , trim , index , scan , verify , repeat , adjustr , adjustl public :: lgt , lge , llt , lle , char , ichar , iachar public :: assignment ( = ) public :: operator (. gt .), operator (. ge .), operator (. lt .), operator (. le .) public :: operator (. eq .), operator (. ne .), operator ( // ) public :: write ( formatted ), write ( unformatted ) public :: read ( formatted ), read ( unformatted ) !> String type holding an arbitrary sequence of characters. type :: string_type sequence private character ( len = :), allocatable :: raw end type string_type !> Constructor for new string instances interface string_type module procedure :: new_string module procedure :: new_string_from_chars end interface string_type !> Returns the length of the character sequence represented by the string. !> !> This method is elemental and returns a default integer scalar value. interface len module procedure :: len_string end interface len !> Returns the length of the character sequence without trailing spaces !> represented by the string. !> !> This method is elemental and returns a default integer scalar value. interface len_trim module procedure :: len_trim_string end interface len_trim !> Returns the character sequence hold by the string without trailing spaces. !> !> This method is elemental and returns a scalar character value. interface trim module procedure :: trim_string end interface trim !> Left-adjust the character sequence represented by the string. !> The length of the character sequence remains unchanged. !> !> This method is elemental and returns a scalar character value. interface adjustl module procedure :: adjustl_string end interface adjustl !> Right-adjust the character sequence represented by the string. !> The length of the character sequence remains unchanged. !> !> This method is elemental and returns a scalar character value. interface adjustr module procedure :: adjustr_string end interface adjustr !> Repeats the character sequence hold by the string by the number of !> specified copies. !> !> This method is elemental and returns a scalar character value. interface repeat module procedure :: repeat_string end interface repeat !> Return the character sequence represented by the string. !> !> This method is elemental and returns a scalar character value. interface char module procedure :: char_string module procedure :: char_string_pos module procedure :: char_string_range end interface char !> Character-to-integer conversion function. !> !> This method is elemental and returns a default integer scalar value. interface ichar module procedure :: ichar_string end interface ichar !> Code in ASCII collating sequence. !> !> This method is elemental and returns a default integer scalar value. interface iachar module procedure :: iachar_string end interface iachar !> Position of a *substring* within a *string*. !> !> Returns the position of the start of the leftmost or rightmost occurrence !> of string *substring* in *string*, counting from one. If *substring* is not !> present in *string*, zero is returned. !> !> This method is elemental and returns a default integer scalar value. interface index module procedure :: index_string_string module procedure :: index_string_char module procedure :: index_char_string end interface index !> Scan a *string* for the presence of a *set* of characters. Scans a *string* for !> any of the characters in a *set* of characters. !> !> If *back* is either absent or *false*, this function returns the position !> of the leftmost character of *string* that is in *set*. If *back* is *true*, !> the rightmost position is returned. If no character of *set* is found in !> *string*, the result is zero. !> !> This method is elemental and returns a default integer scalar value. interface scan module procedure :: scan_string_string module procedure :: scan_string_char module procedure :: scan_char_string end interface scan !> Scan a string for the absence of a set of characters. Verifies that all !> the characters in string belong to the set of characters in set. !> !> If *back* is either absent or *false*, this function returns the position !> of the leftmost character of *string* that is not in *set*. If *back* is *true*, !> the rightmost position is returned. If all characters of *string* are found !> in *set*, the result is zero. !> !> This method is elemental and returns a default integer scalar value. interface verify module procedure :: verify_string_string module procedure :: verify_string_char module procedure :: verify_char_string end interface verify !> Lexically compare the order of two character sequences being greater, !> The left-hand side, the right-hand side or both character sequences can !> be represented by a string. !> !> This method is elemental and returns a default logical scalar value. interface lgt module procedure :: lgt_string_string module procedure :: lgt_string_char module procedure :: lgt_char_string end interface lgt !> Lexically compare the order of two character sequences being less, !> The left-hand side, the right-hand side or both character sequences can !> be represented by a string. !> !> This method is elemental and returns a default logical scalar value. interface llt module procedure :: llt_string_string module procedure :: llt_string_char module procedure :: llt_char_string end interface llt !> Lexically compare the order of two character sequences being greater equal, !> The left-hand side, the right-hand side or both character sequences can !> be represented by a string. !> !> This method is elemental and returns a default logical scalar value. interface lge module procedure :: lge_string_string module procedure :: lge_string_char module procedure :: lge_char_string end interface lge !> Lexically compare the order of two character sequences being less equal, !> The left-hand side, the right-hand side or both character sequences can !> be represented by a string. !> !> This method is elemental and returns a default logical scalar value. interface lle module procedure :: lle_string_string module procedure :: lle_string_char module procedure :: lle_char_string end interface lle !> Assign a character sequence to a string. interface assignment ( = ) module procedure :: assign_string_char module procedure :: assign_string_chars end interface assignment ( = ) !> Compare two character sequences for being greater, the left-hand side, !> the right-hand side or both character sequences can be represented by !> a string. !> !> This operator is elemental and returns a default logical scalar value. interface operator (. gt .) module procedure :: gt_string_string module procedure :: gt_string_char module procedure :: gt_char_string end interface operator (. gt .) !> Compare two character sequences for being less, the left-hand side, !> the right-hand side or both character sequences can be represented by !> a string. !> !> This operator is elemental and returns a default logical scalar value. interface operator (. lt .) module procedure :: lt_string_string module procedure :: lt_string_char module procedure :: lt_char_string end interface operator (. lt .) !> Compare two character sequences for being greater than, the left-hand side, !> the right-hand side or both character sequences can be represented by !> a string. !> !> This operator is elemental and returns a default logical scalar value. interface operator (. ge .) module procedure :: ge_string_string module procedure :: ge_string_char module procedure :: ge_char_string end interface operator (. ge .) !> Compare two character sequences for being less than, the left-hand side, !> the right-hand side or both character sequences can be represented by !> a string. !> !> This operator is elemental and returns a default logical scalar value. interface operator (. le .) module procedure :: le_string_string module procedure :: le_string_char module procedure :: le_char_string end interface operator (. le .) !> Compare two character sequences for equality, the left-hand side, !> the right-hand side or both character sequences can be represented by !> a string. !> !> This operator is elemental and returns a default logical scalar value. interface operator (. eq .) module procedure :: eq_string_string module procedure :: eq_string_char module procedure :: eq_char_string end interface operator (. eq .) !> Compare two character sequences for inequality, the left-hand side, !> the right-hand side or both character sequences can be represented by !> a string. !> !> This operator is elemental and returns a default logical scalar value. interface operator (. ne .) module procedure :: ne_string_string module procedure :: ne_string_char module procedure :: ne_char_string end interface operator (. ne .) !> Concatenate two character sequences, the left-hand side, the right-hand side !> or both character sequences can be represented by a string. !> !> This operator is elemental and returns a scalar character value. interface operator ( // ) module procedure :: concat_string_string module procedure :: concat_string_char module procedure :: concat_char_string end interface operator ( // ) !> Write the character sequence hold by the string to a connected formatted !> unit. interface write ( formatted ) module procedure :: write_formatted end interface !> Write the character sequence hold by the string to a connected unformatted !> unit. interface write ( unformatted ) module procedure :: write_unformatted end interface !> Read a character sequence from a connected unformatted unit into the string. interface read ( formatted ) module procedure :: read_formatted end interface !> Read a character sequence from a connected unformatted unit into the string. interface read ( unformatted ) module procedure :: read_unformatted end interface contains !> Constructor for new string instances from a scalar character value. elemental function new_string ( string ) result ( new ) character ( len =* ), intent ( in ), optional :: string type ( string_type ) :: new if ( present ( string )) new % raw = string end function new_string !> Constructor for new string instances from an array of characters. pure function new_string_from_chars ( chars ) result ( new ) character ( len =* ), intent ( in ) :: chars (:) type ( string_type ) :: new allocate ( character ( len = len ( chars ) * size ( chars )) :: new % raw ) new % raw = transfer ( chars , new % raw ) end function new_string_from_chars !> Assign a character sequence to a string. elemental subroutine assign_string_char ( lhs , rhs ) type ( string_type ), intent ( inout ) :: lhs character ( len =* ), intent ( in ) :: rhs lhs % raw = rhs end subroutine assign_string_char !> Assign a character sequence to a string. pure subroutine assign_string_chars ( lhs , rhs ) type ( string_type ), intent ( inout ) :: lhs character ( len =* ), intent ( in ) :: rhs (:) allocate ( character ( len = len ( rhs ) * size ( rhs )) :: lhs % raw ) lhs % raw = transfer ( rhs , lhs % raw ) end subroutine assign_string_chars !> Returns the length of the character sequence represented by the string. elemental function len_string ( string ) result ( length ) type ( string_type ), intent ( in ) :: string integer :: length length = merge ( len ( string % raw ), 0 , allocated ( string % raw )) end function len_string !> Returns the length of the character sequence without trailing spaces !> represented by the string. elemental function len_trim_string ( string ) result ( length ) type ( string_type ), intent ( in ) :: string integer :: length length = merge ( len_trim ( string % raw ), 0 , allocated ( string % raw )) end function len_trim_string !> Character-to-integer conversion function. elemental function ichar_string ( string ) result ( ich ) type ( string_type ), intent ( in ) :: string integer :: ich ich = merge ( ichar ( string % raw ), 0 , allocated ( string % raw )) end function ichar_string !> Code in ASCII collating sequence. elemental function iachar_string ( string ) result ( ich ) type ( string_type ), intent ( in ) :: string integer :: ich ich = merge ( iachar ( string % raw ), 0 , allocated ( string % raw )) end function iachar_string !> Return the character sequence represented by the string. elemental function char_string ( string ) result ( character_string ) type ( string_type ), intent ( in ) :: string character ( len = len ( string )) :: character_string character_string = maybe ( string ) end function char_string !> Return the character sequence represented by the string. elemental function char_string_pos ( string , pos ) result ( character_string ) type ( string_type ), intent ( in ) :: string integer , intent ( in ) :: pos character ( len = 1 ) :: character_string character_string = merge ( string % raw ( pos : pos ), ' ' , allocated ( string % raw )) end function char_string_pos !> Return the character sequence represented by the string. elemental function char_string_range ( string , start , last ) result ( character_string ) type ( string_type ), intent ( in ) :: string integer , intent ( in ) :: start integer , intent ( in ) :: last character ( len = max ( last - start + 1 , 0 )) :: character_string integer , parameter :: long = selected_int_kind ( 18 ) character_string = merge ( string % raw ( int ( start , long ): int ( last , long )), & repeat ( ' ' , int ( len ( character_string ), long )), allocated ( string % raw )) end function char_string_range !> Returns the character sequence hold by the string without trailing spaces. elemental function trim_string ( string ) result ( trimmed_string ) type ( string_type ), intent ( in ) :: string character ( len = len_trim ( string )) :: trimmed_string trimmed_string = trim ( maybe ( string )) end function trim_string !> Left-adjust the character sequence represented by the string. !> The length of the character sequence remains unchanged. elemental function adjustl_string ( string ) result ( adjusted_string ) type ( string_type ), intent ( in ) :: string character ( len = len ( string )) :: adjusted_string adjusted_string = adjustl ( maybe ( string )) end function adjustl_string !> Right-adjust the character sequence represented by the string. !> The length of the character sequence remains unchanged. elemental function adjustr_string ( string ) result ( adjusted_string ) type ( string_type ), intent ( in ) :: string character ( len = len ( string )) :: adjusted_string adjusted_string = adjustr ( maybe ( string )) end function adjustr_string !> Repeats the character sequence hold by the string by the number of !> specified copies. elemental function repeat_string ( string , ncopies ) result ( repeated_string ) type ( string_type ), intent ( in ) :: string integer , intent ( in ) :: ncopies character ( len = len ( string ) * ncopies ) :: repeated_string repeated_string = repeat ( maybe ( string ), ncopies ) end function repeat_string !> Position of a sequence of character within a character sequence. !> In this version both character sequences are represented by a string. elemental function index_string_string ( string , substring , back ) result ( pos ) type ( string_type ), intent ( in ) :: string type ( string_type ), intent ( in ) :: substring logical , intent ( in ), optional :: back integer :: pos pos = index ( maybe ( string ), maybe ( substring ), & merge ( back , . false ., present ( back ))) end function index_string_string !> Position of a sequence of character within a character sequence. !> In this version the main character sequence is represented by a string. elemental function index_string_char ( string , substring , back ) result ( pos ) type ( string_type ), intent ( in ) :: string character ( len =* ), intent ( in ) :: substring logical , intent ( in ), optional :: back integer :: pos pos = index ( maybe ( string ), substring , & merge ( back , . false ., present ( back ))) end function index_string_char !> Position of a sequence of character within a character sequence. !> In this version the sub character sequence is represented by a string. elemental function index_char_string ( string , substring , back ) result ( pos ) character ( len =* ), intent ( in ) :: string type ( string_type ), intent ( in ) :: substring logical , intent ( in ), optional :: back integer :: pos pos = index ( string , maybe ( substring ), & merge ( back , . false ., present ( back ))) end function index_char_string !> Scan a character sequence for any of the characters in a set of characters. !> In this version both the character sequence and the character set are !> represented by a string. elemental function scan_string_string ( string , set , back ) result ( pos ) type ( string_type ), intent ( in ) :: string type ( string_type ), intent ( in ) :: set logical , intent ( in ), optional :: back integer :: pos pos = scan ( maybe ( string ), maybe ( set ), & merge ( back , . false ., present ( back ))) end function scan_string_string !> Scan a character sequence for any of the characters in a set of characters. !> In this version the character sequences is represented by a string. elemental function scan_string_char ( string , set , back ) result ( pos ) type ( string_type ), intent ( in ) :: string character ( len =* ), intent ( in ) :: set logical , intent ( in ), optional :: back integer :: pos pos = scan ( maybe ( string ), set , & merge ( back , . false ., present ( back ))) end function scan_string_char !> Scan a character sequence for any of the characters in a set of characters. !> In this version the set of characters is represented by a string. elemental function scan_char_string ( string , set , back ) result ( pos ) character ( len =* ), intent ( in ) :: string type ( string_type ), intent ( in ) :: set logical , intent ( in ), optional :: back integer :: pos pos = scan ( string , maybe ( set ), & merge ( back , . false ., present ( back ))) end function scan_char_string !> Verify a character sequence for the absence any of the characters in !> a set of characters. In this version both the character sequence and !> the character set are represented by a string. elemental function verify_string_string ( string , set , back ) result ( pos ) type ( string_type ), intent ( in ) :: string type ( string_type ), intent ( in ) :: set logical , intent ( in ), optional :: back integer :: pos pos = verify ( maybe ( string ), maybe ( set ), & merge ( back , . false ., present ( back ))) end function verify_string_string !> Verify a character sequence for the absence any of the characters in !> a set of characters. In this version the character sequences is !> represented by a string. elemental function verify_string_char ( string , set , back ) result ( pos ) type ( string_type ), intent ( in ) :: string character ( len =* ), intent ( in ) :: set logical , intent ( in ), optional :: back integer :: pos pos = verify ( maybe ( string ), set , & merge ( back , . false ., present ( back ))) end function verify_string_char !> Verify a character sequence for the absence any of the characters in !> a set of characters. In this version the set of characters is !> represented by a string. elemental function verify_char_string ( string , set , back ) result ( pos ) character ( len =* ), intent ( in ) :: string type ( string_type ), intent ( in ) :: set logical , intent ( in ), optional :: back integer :: pos pos = verify ( string , maybe ( set ), & merge ( back , . false ., present ( back ))) end function verify_char_string !> Compare two character sequences for being greater. !> In this version both character sequences are by a string. elemental function gt_string_string ( lhs , rhs ) result ( is_gt ) type ( string_type ), intent ( in ) :: lhs type ( string_type ), intent ( in ) :: rhs logical :: is_gt is_gt = maybe ( lhs ) > maybe ( rhs ) end function gt_string_string !> Compare two character sequences for being greater. !> In this version the left-hand side character sequences is by a string. elemental function gt_string_char ( lhs , rhs ) result ( is_gt ) type ( string_type ), intent ( in ) :: lhs character ( len =* ), intent ( in ) :: rhs logical :: is_gt is_gt = maybe ( lhs ) > rhs end function gt_string_char !> Compare two character sequences for being greater. !> In this version the right-hand side character sequences is by a string. elemental function gt_char_string ( lhs , rhs ) result ( is_gt ) character ( len =* ), intent ( in ) :: lhs type ( string_type ), intent ( in ) :: rhs logical :: is_gt is_gt = lhs > maybe ( rhs ) end function gt_char_string !> Compare two character sequences for being less. !> In this version both character sequences are by a string. elemental function lt_string_string ( lhs , rhs ) result ( is_lt ) type ( string_type ), intent ( in ) :: lhs type ( string_type ), intent ( in ) :: rhs logical :: is_lt is_lt = rhs > lhs end function lt_string_string !> Compare two character sequences for being less. !> In this version the left-hand side character sequences is by a string. elemental function lt_string_char ( lhs , rhs ) result ( is_lt ) type ( string_type ), intent ( in ) :: lhs character ( len =* ), intent ( in ) :: rhs logical :: is_lt is_lt = rhs > lhs end function lt_string_char !> Compare two character sequences for being less. !> In this version the right-hand side character sequences is by a string. elemental function lt_char_string ( lhs , rhs ) result ( is_lt ) character ( len =* ), intent ( in ) :: lhs type ( string_type ), intent ( in ) :: rhs logical :: is_lt is_lt = rhs > lhs end function lt_char_string !> Compare two character sequences for being greater or equal. !> In this version both character sequences are by a string. elemental function ge_string_string ( lhs , rhs ) result ( is_ge ) type ( string_type ), intent ( in ) :: lhs type ( string_type ), intent ( in ) :: rhs logical :: is_ge is_ge = . not . ( rhs > lhs ) end function ge_string_string !> Compare two character sequences for being greater or equal. !> In this version the left-hand side character sequences is by a string. elemental function ge_string_char ( lhs , rhs ) result ( is_ge ) type ( string_type ), intent ( in ) :: lhs character ( len =* ), intent ( in ) :: rhs logical :: is_ge is_ge = . not . ( rhs > lhs ) end function ge_string_char !> Compare two character sequences for being greater or equal !> In this version the right-hand side character sequences is by a string. elemental function ge_char_string ( lhs , rhs ) result ( is_ge ) character ( len =* ), intent ( in ) :: lhs type ( string_type ), intent ( in ) :: rhs logical :: is_ge is_ge = . not . ( rhs > lhs ) end function ge_char_string !> Compare two character sequences for being less or equal. !> In this version both character sequences are by a string. elemental function le_string_string ( lhs , rhs ) result ( is_le ) type ( string_type ), intent ( in ) :: lhs type ( string_type ), intent ( in ) :: rhs logical :: is_le is_le = . not . ( lhs > rhs ) end function le_string_string !> Compare two character sequences for being less or equal. !> In this version the left-hand side character sequences is by a string. elemental function le_string_char ( lhs , rhs ) result ( is_le ) type ( string_type ), intent ( in ) :: lhs character ( len =* ), intent ( in ) :: rhs logical :: is_le is_le = . not . ( lhs > rhs ) end function le_string_char !> Compare two character sequences for being less or equal !> In this version the right-hand side character sequences is by a string. elemental function le_char_string ( lhs , rhs ) result ( is_le ) character ( len =* ), intent ( in ) :: lhs type ( string_type ), intent ( in ) :: rhs logical :: is_le is_le = . not . ( lhs > rhs ) end function le_char_string !> Compare two character sequences for equality. !> In this version both character sequences are by a string. elemental function eq_string_string ( lhs , rhs ) result ( is_eq ) type ( string_type ), intent ( in ) :: lhs type ( string_type ), intent ( in ) :: rhs logical :: is_eq is_eq = . not .( lhs > rhs ) if ( is_eq ) then is_eq = . not .( rhs > lhs ) end if end function eq_string_string !> Compare two character sequences for equality. !> In this version the left-hand side character sequences is by a string. elemental function eq_string_char ( lhs , rhs ) result ( is_eq ) type ( string_type ), intent ( in ) :: lhs character ( len =* ), intent ( in ) :: rhs logical :: is_eq is_eq = . not .( lhs > rhs ) if ( is_eq ) then is_eq = . not .( rhs > lhs ) end if end function eq_string_char !> Compare two character sequences for equality. !> In this version the right-hand side character sequences is by a string. elemental function eq_char_string ( lhs , rhs ) result ( is_eq ) character ( len =* ), intent ( in ) :: lhs type ( string_type ), intent ( in ) :: rhs logical :: is_eq is_eq = . not .( lhs > rhs ) if ( is_eq ) then is_eq = . not .( rhs > lhs ) end if end function eq_char_string !> Compare two character sequences for inequality. !> In this version both character sequences are by a string. elemental function ne_string_string ( lhs , rhs ) result ( is_ne ) type ( string_type ), intent ( in ) :: lhs type ( string_type ), intent ( in ) :: rhs logical :: is_ne is_ne = lhs > rhs if (. not . is_ne ) then is_ne = rhs > lhs end if end function ne_string_string !> Compare two character sequences for inequality. !> In this version the left-hand side character sequences is by a string. elemental function ne_string_char ( lhs , rhs ) result ( is_ne ) type ( string_type ), intent ( in ) :: lhs character ( len =* ), intent ( in ) :: rhs logical :: is_ne is_ne = lhs > rhs if (. not . is_ne ) then is_ne = rhs > lhs end if end function ne_string_char !> Compare two character sequences for inequality. !> In this version the right-hand side character sequences is by a string. elemental function ne_char_string ( lhs , rhs ) result ( is_ne ) character ( len =* ), intent ( in ) :: lhs type ( string_type ), intent ( in ) :: rhs logical :: is_ne is_ne = lhs > rhs if (. not . is_ne ) then is_ne = rhs > lhs end if end function ne_char_string !> Lexically compare two character sequences for being greater. !> In this version both character sequences are by a string. elemental function lgt_string_string ( lhs , rhs ) result ( is_lgt ) type ( string_type ), intent ( in ) :: lhs type ( string_type ), intent ( in ) :: rhs logical :: is_lgt is_lgt = lgt ( maybe ( lhs ), maybe ( rhs )) end function lgt_string_string !> Lexically compare two character sequences for being greater. !> In this version the left-hand side character sequences is by a string. elemental function lgt_string_char ( lhs , rhs ) result ( is_lgt ) type ( string_type ), intent ( in ) :: lhs character ( len =* ), intent ( in ) :: rhs logical :: is_lgt is_lgt = lgt ( maybe ( lhs ), rhs ) end function lgt_string_char !> Lexically compare two character sequences for being greater. !> In this version the right-hand side character sequences is by a string. elemental function lgt_char_string ( lhs , rhs ) result ( is_lgt ) character ( len =* ), intent ( in ) :: lhs type ( string_type ), intent ( in ) :: rhs logical :: is_lgt is_lgt = lgt ( lhs , maybe ( rhs )) end function lgt_char_string !> Lexically compare two character sequences for being less. !> In this version both character sequences are by a string. elemental function llt_string_string ( lhs , rhs ) result ( is_llt ) type ( string_type ), intent ( in ) :: lhs type ( string_type ), intent ( in ) :: rhs logical :: is_llt is_llt = llt ( maybe ( lhs ), maybe ( rhs )) end function llt_string_string !> Lexically compare two character sequences for being less. !> In this version the left-hand side character sequences is by a string. elemental function llt_string_char ( lhs , rhs ) result ( is_llt ) type ( string_type ), intent ( in ) :: lhs character ( len =* ), intent ( in ) :: rhs logical :: is_llt is_llt = llt ( maybe ( lhs ), rhs ) end function llt_string_char !> Lexically compare two character sequences for being less. !> In this version the right-hand side character sequences is by a string. elemental function llt_char_string ( lhs , rhs ) result ( is_llt ) character ( len =* ), intent ( in ) :: lhs type ( string_type ), intent ( in ) :: rhs logical :: is_llt is_llt = llt ( lhs , maybe ( rhs )) end function llt_char_string !> Lexically compare two character sequences for being greater or equal. !> In this version both character sequences are by a string. elemental function lge_string_string ( lhs , rhs ) result ( is_lge ) type ( string_type ), intent ( in ) :: lhs type ( string_type ), intent ( in ) :: rhs logical :: is_lge is_lge = lge ( maybe ( lhs ), maybe ( rhs )) end function lge_string_string !> Lexically compare two character sequences for being greater or equal. !> In this version the left-hand side character sequences is by a string. elemental function lge_string_char ( lhs , rhs ) result ( is_lge ) type ( string_type ), intent ( in ) :: lhs character ( len =* ), intent ( in ) :: rhs logical :: is_lge is_lge = lge ( maybe ( lhs ), rhs ) end function lge_string_char !> Lexically compare two character sequences for being greater or equal !> In this version the right-hand side character sequences is by a string. elemental function lge_char_string ( lhs , rhs ) result ( is_lge ) character ( len =* ), intent ( in ) :: lhs type ( string_type ), intent ( in ) :: rhs logical :: is_lge is_lge = lge ( lhs , maybe ( rhs )) end function lge_char_string !> Lexically compare two character sequences for being less or equal. !> In this version both character sequences are by a string. elemental function lle_string_string ( lhs , rhs ) result ( is_lle ) type ( string_type ), intent ( in ) :: lhs type ( string_type ), intent ( in ) :: rhs logical :: is_lle is_lle = lle ( maybe ( lhs ), maybe ( rhs )) end function lle_string_string !> Lexically compare two character sequences for being less or equal. !> In this version the left-hand side character sequences is by a string. elemental function lle_string_char ( lhs , rhs ) result ( is_lle ) type ( string_type ), intent ( in ) :: lhs character ( len =* ), intent ( in ) :: rhs logical :: is_lle is_lle = lle ( maybe ( lhs ), rhs ) end function lle_string_char !> Lexically compare two character sequences for being less or equal !> In this version the right-hand side character sequences is by a string. elemental function lle_char_string ( lhs , rhs ) result ( is_lle ) character ( len =* ), intent ( in ) :: lhs type ( string_type ), intent ( in ) :: rhs logical :: is_lle is_lle = lle ( lhs , maybe ( rhs )) end function lle_char_string !> Concatenate two character sequences. !> In this version both character sequences are by a string. elemental function concat_string_string ( lhs , rhs ) result ( string ) type ( string_type ), intent ( in ) :: lhs type ( string_type ), intent ( in ) :: rhs character ( len = len ( lhs ) + len ( rhs )) :: string string = maybe ( rhs ) // maybe ( lhs ) end function concat_string_string !> Concatenate two character sequences. !> In this version the left-hand side character sequences is by a string. elemental function concat_string_char ( lhs , rhs ) result ( string ) type ( string_type ), intent ( in ) :: lhs character ( len =* ), intent ( in ) :: rhs character ( len = len ( lhs ) + len ( rhs )) :: string string = maybe ( lhs ) // rhs end function concat_string_char !> Concatenate two character sequences. !> In this version the right-hand side character sequences is by a string. elemental function concat_char_string ( lhs , rhs ) result ( string ) character ( len =* ), intent ( in ) :: lhs type ( string_type ), intent ( in ) :: rhs character ( len = len ( lhs ) + len ( rhs )) :: string string = lhs // maybe ( rhs ) end function concat_char_string !> Write the character sequence hold by the string to a connected unformatted !> unit. subroutine write_unformatted ( string , unit , iostat , iomsg ) type ( string_type ), intent ( in ) :: string integer , intent ( in ) :: unit integer , intent ( out ) :: iostat character ( len =* ), intent ( inout ) :: iomsg integer , parameter :: long = selected_int_kind ( 18 ) write ( unit , iostat = iostat , iomsg = iomsg ) int ( len ( string ), long ) if ( iostat == 0 ) then write ( unit , iostat = iostat , iomsg = iomsg ) maybe ( string ) end if end subroutine write_unformatted !> Write the character sequence hold by the string to a connected formatted !> unit. subroutine write_formatted ( string , unit , iotype , v_list , iostat , iomsg ) type ( string_type ), intent ( in ) :: string integer , intent ( in ) :: unit character ( len =* ), intent ( in ) :: iotype integer , intent ( in ) :: v_list (:) integer , intent ( out ) :: iostat character ( len =* ), intent ( inout ) :: iomsg call unused_dummy_argument ( iotype ) call unused_dummy_argument ( v_list ) write ( unit , '(a)' , iostat = iostat , iomsg = iomsg ) maybe ( string ) end subroutine write_formatted !> Read a character sequence from a connected unformatted unit into the string. subroutine read_unformatted ( string , unit , iostat , iomsg ) type ( string_type ), intent ( inout ) :: string integer , intent ( in ) :: unit integer , intent ( out ) :: iostat character ( len =* ), intent ( inout ) :: iomsg integer , parameter :: long = selected_int_kind ( 18 ) integer ( long ) :: chunk read ( unit , iostat = iostat , iomsg = iomsg ) chunk if ( iostat == 0 ) then string % raw = repeat ( ' ' , chunk ) read ( unit , iostat = iostat , iomsg = iomsg ) string % raw end if end subroutine read_unformatted !> Read a character sequence from a connected formatted unit into the string. subroutine read_formatted ( string , unit , iotype , v_list , iostat , iomsg ) type ( string_type ), intent ( inout ) :: string integer , intent ( in ) :: unit character ( len =* ), intent ( in ) :: iotype integer , intent ( in ) :: v_list (:) integer , intent ( out ) :: iostat character ( len =* ), intent ( inout ) :: iomsg integer , parameter :: buffer_size = 512 character ( len = buffer_size ) :: buffer integer :: chunk call unused_dummy_argument ( iotype ) call unused_dummy_argument ( v_list ) string % raw = '' do read ( unit , '(a)' , iostat = iostat , iomsg = iomsg , size = chunk , advance = 'no' ) & buffer if ( iostat > 0 ) exit string % raw = string % raw // buffer (: chunk ) if ( iostat < 0 ) then if ( is_iostat_eor ( iostat )) then iostat = 0 end if exit end if end do end subroutine read_formatted !> Do nothing but mark an unused dummy argument as such to acknowledge compile !> time warning like: !> !>   Warning: Unused dummy argument â€˜dummyâ€™ at (1) [-Wunused-dummy-argument] !> !> We deeply trust in the compiler to inline and optimize this piece of code away. elemental subroutine unused_dummy_argument ( dummy ) class ( * ), intent ( in ) :: dummy associate ( dummy => dummy ); end associate end subroutine unused_dummy_argument !> Safely return the character sequences represented by the string elemental function maybe ( string ) result ( maybe_string ) type ( string_type ), intent ( in ) :: string character ( len = len ( string )) :: maybe_string if ( allocated ( string % raw )) then maybe_string = string % raw else maybe_string = '' end if end function maybe end module stdlib_string_type","tags":"","loc":"sourcefile/stdlib_string_type.f90.html"},{"title":"string_type â€“ stdlib_string ","text":"type, public :: string_type sequence String type holding an arbitrary sequence of characters. Contents Constructor string_type Source Code string_type Constructor public interface string_type Constructor for new string instances private elemental function new_string(string) result(new) Constructor for new string instances from a scalar character value. Arguments Type Intent Optional Attributes Name character(len=*), intent(in), optional :: string Return Value type( string_type ) private pure function new_string_from_chars(chars) result(new) Constructor for new string instances from an array of characters. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: chars (:) Return Value type( string_type ) Source Code type :: string_type sequence private character ( len = :), allocatable :: raw end type string_type","tags":"","loc":"type/string_type.html"},{"title":"adjustl â€“ stdlib_string","text":"public interface adjustl Left-adjust the character sequence represented by the string.\n The length of the character sequence remains unchanged. This method is elemental and returns a scalar character value. Contents Module Procedures adjustl_string Module Procedures private elemental function adjustl_string(string) result(adjusted_string) Left-adjust the character sequence represented by the string.\n The length of the character sequence remains unchanged. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string Return Value character(len=len(string))","tags":"","loc":"interface/adjustl.html"},{"title":"adjustr â€“ stdlib_string","text":"public interface adjustr Right-adjust the character sequence represented by the string.\n The length of the character sequence remains unchanged. This method is elemental and returns a scalar character value. Contents Module Procedures adjustr_string Module Procedures private elemental function adjustr_string(string) result(adjusted_string) Right-adjust the character sequence represented by the string.\n The length of the character sequence remains unchanged. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string Return Value character(len=len(string))","tags":"","loc":"interface/adjustr.html"},{"title":"assignment(=) â€“ stdlib_string","text":"public interface assignment(=) Assign a character sequence to a string. Contents Module Procedures assign_string_char assign_string_chars Module Procedures private elemental subroutine assign_string_char(lhs, rhs) Assign a character sequence to a string. Arguments Type Intent Optional Attributes Name type( string_type ), intent(inout) :: lhs character(len=*), intent(in) :: rhs private pure subroutine assign_string_chars(lhs, rhs) Assign a character sequence to a string. Arguments Type Intent Optional Attributes Name type( string_type ), intent(inout) :: lhs character(len=*), intent(in) :: rhs (:)","tags":"","loc":"interface/assignment(=).html"},{"title":"char â€“ stdlib_string","text":"public interface char Return the character sequence represented by the string. This method is elemental and returns a scalar character value. Contents Module Procedures char_string char_string_pos char_string_range Module Procedures private elemental function char_string(string) result(character_string) Return the character sequence represented by the string. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string Return Value character(len=len(string)) private elemental function char_string_pos(string, pos) result(character_string) Return the character sequence represented by the string. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string integer, intent(in) :: pos Return Value character(len=1) private elemental function char_string_range(string, start, last) result(character_string) Return the character sequence represented by the string. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string integer, intent(in) :: start integer, intent(in) :: last Return Value character(len=max(last-start+1,0))","tags":"","loc":"interface/char.html"},{"title":"iachar â€“ stdlib_string","text":"public interface iachar Code in ASCII collating sequence. This method is elemental and returns a default integer scalar value. Contents Module Procedures iachar_string Module Procedures private elemental function iachar_string(string) result(ich) Code in ASCII collating sequence. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string Return Value integer","tags":"","loc":"interface/iachar.html"},{"title":"ichar â€“ stdlib_string","text":"public interface ichar Character-to-integer conversion function. This method is elemental and returns a default integer scalar value. Contents Module Procedures ichar_string Module Procedures private elemental function ichar_string(string) result(ich) Character-to-integer conversion function. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string Return Value integer","tags":"","loc":"interface/ichar.html"},{"title":"index â€“ stdlib_string","text":"public interface index Position of a substring within a string . Returns the position of the start of the leftmost or rightmost occurrence\n of string substring in string , counting from one. If substring is not\n present in string , zero is returned. This method is elemental and returns a default integer scalar value. Contents Module Procedures index_string_string index_string_char index_char_string Module Procedures private elemental function index_string_string(string, substring, back) result(pos) Position of a sequence of character within a character sequence.\n In this version both character sequences are represented by a string. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string type( string_type ), intent(in) :: substring logical, intent(in), optional :: back Return Value integer private elemental function index_string_char(string, substring, back) result(pos) Position of a sequence of character within a character sequence.\n In this version the main character sequence is represented by a string. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string character(len=*), intent(in) :: substring logical, intent(in), optional :: back Return Value integer private elemental function index_char_string(string, substring, back) result(pos) Position of a sequence of character within a character sequence.\n In this version the sub character sequence is represented by a string. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string type( string_type ), intent(in) :: substring logical, intent(in), optional :: back Return Value integer","tags":"","loc":"interface/index.html"},{"title":"len â€“ stdlib_string","text":"public interface len Returns the length of the character sequence represented by the string. This method is elemental and returns a default integer scalar value. Contents Module Procedures len_string Module Procedures private elemental function len_string(string) result(length) Returns the length of the character sequence represented by the string. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string Return Value integer","tags":"","loc":"interface/len.html"},{"title":"len_trim â€“ stdlib_string","text":"public interface len_trim Returns the length of the character sequence without trailing spaces\n represented by the string. This method is elemental and returns a default integer scalar value. Contents Module Procedures len_trim_string Module Procedures private elemental function len_trim_string(string) result(length) Returns the length of the character sequence without trailing spaces\n represented by the string. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string Return Value integer","tags":"","loc":"interface/len_trim.html"},{"title":"lge â€“ stdlib_string","text":"public interface lge Lexically compare the order of two character sequences being greater equal,\n The left-hand side, the right-hand side or both character sequences can\n be represented by a string. This method is elemental and returns a default logical scalar value. Contents Module Procedures lge_string_string lge_string_char lge_char_string Module Procedures private elemental function lge_string_string(lhs, rhs) result(is_lge) Lexically compare two character sequences for being greater or equal.\n In this version both character sequences are by a string. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: lhs type( string_type ), intent(in) :: rhs Return Value logical private elemental function lge_string_char(lhs, rhs) result(is_lge) Lexically compare two character sequences for being greater or equal.\n In this version the left-hand side character sequences is by a string. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: lhs character(len=*), intent(in) :: rhs Return Value logical private elemental function lge_char_string(lhs, rhs) result(is_lge) Lexically compare two character sequences for being greater or equal\n In this version the right-hand side character sequences is by a string. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: lhs type( string_type ), intent(in) :: rhs Return Value logical","tags":"","loc":"interface/lge.html"},{"title":"lgt â€“ stdlib_string","text":"public interface lgt Lexically compare the order of two character sequences being greater,\n The left-hand side, the right-hand side or both character sequences can\n be represented by a string. This method is elemental and returns a default logical scalar value. Contents Module Procedures lgt_string_string lgt_string_char lgt_char_string Module Procedures private elemental function lgt_string_string(lhs, rhs) result(is_lgt) Lexically compare two character sequences for being greater.\n In this version both character sequences are by a string. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: lhs type( string_type ), intent(in) :: rhs Return Value logical private elemental function lgt_string_char(lhs, rhs) result(is_lgt) Lexically compare two character sequences for being greater.\n In this version the left-hand side character sequences is by a string. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: lhs character(len=*), intent(in) :: rhs Return Value logical private elemental function lgt_char_string(lhs, rhs) result(is_lgt) Lexically compare two character sequences for being greater.\n In this version the right-hand side character sequences is by a string. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: lhs type( string_type ), intent(in) :: rhs Return Value logical","tags":"","loc":"interface/lgt.html"},{"title":"lle â€“ stdlib_string","text":"public interface lle Lexically compare the order of two character sequences being less equal,\n The left-hand side, the right-hand side or both character sequences can\n be represented by a string. This method is elemental and returns a default logical scalar value. Contents Module Procedures lle_string_string lle_string_char lle_char_string Module Procedures private elemental function lle_string_string(lhs, rhs) result(is_lle) Lexically compare two character sequences for being less or equal.\n In this version both character sequences are by a string. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: lhs type( string_type ), intent(in) :: rhs Return Value logical private elemental function lle_string_char(lhs, rhs) result(is_lle) Lexically compare two character sequences for being less or equal.\n In this version the left-hand side character sequences is by a string. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: lhs character(len=*), intent(in) :: rhs Return Value logical private elemental function lle_char_string(lhs, rhs) result(is_lle) Lexically compare two character sequences for being less or equal\n In this version the right-hand side character sequences is by a string. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: lhs type( string_type ), intent(in) :: rhs Return Value logical","tags":"","loc":"interface/lle.html"},{"title":"llt â€“ stdlib_string","text":"public interface llt Lexically compare the order of two character sequences being less,\n The left-hand side, the right-hand side or both character sequences can\n be represented by a string. This method is elemental and returns a default logical scalar value. Contents Module Procedures llt_string_string llt_string_char llt_char_string Module Procedures private elemental function llt_string_string(lhs, rhs) result(is_llt) Lexically compare two character sequences for being less.\n In this version both character sequences are by a string. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: lhs type( string_type ), intent(in) :: rhs Return Value logical private elemental function llt_string_char(lhs, rhs) result(is_llt) Lexically compare two character sequences for being less.\n In this version the left-hand side character sequences is by a string. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: lhs character(len=*), intent(in) :: rhs Return Value logical private elemental function llt_char_string(lhs, rhs) result(is_llt) Lexically compare two character sequences for being less.\n In this version the right-hand side character sequences is by a string. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: lhs type( string_type ), intent(in) :: rhs Return Value logical","tags":"","loc":"interface/llt.html"},{"title":"operator(.eq.) â€“ stdlib_string","text":"public interface operator(.eq.) Compare two character sequences for equality, the left-hand side,\n the right-hand side or both character sequences can be represented by\n a string. This operator is elemental and returns a default logical scalar value. Contents Module Procedures eq_string_string eq_string_char eq_char_string Module Procedures private elemental function eq_string_string(lhs, rhs) result(is_eq) Compare two character sequences for equality.\n In this version both character sequences are by a string. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: lhs type( string_type ), intent(in) :: rhs Return Value logical private elemental function eq_string_char(lhs, rhs) result(is_eq) Compare two character sequences for equality.\n In this version the left-hand side character sequences is by a string. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: lhs character(len=*), intent(in) :: rhs Return Value logical private elemental function eq_char_string(lhs, rhs) result(is_eq) Compare two character sequences for equality.\n In this version the right-hand side character sequences is by a string. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: lhs type( string_type ), intent(in) :: rhs Return Value logical","tags":"","loc":"interface/operator(.eq.).html"},{"title":"operator(.ge.) â€“ stdlib_string","text":"public interface operator(.ge.) Compare two character sequences for being greater than, the left-hand side,\n the right-hand side or both character sequences can be represented by\n a string. This operator is elemental and returns a default logical scalar value. Contents Module Procedures ge_string_string ge_string_char ge_char_string Module Procedures private elemental function ge_string_string(lhs, rhs) result(is_ge) Compare two character sequences for being greater or equal.\n In this version both character sequences are by a string. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: lhs type( string_type ), intent(in) :: rhs Return Value logical private elemental function ge_string_char(lhs, rhs) result(is_ge) Compare two character sequences for being greater or equal.\n In this version the left-hand side character sequences is by a string. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: lhs character(len=*), intent(in) :: rhs Return Value logical private elemental function ge_char_string(lhs, rhs) result(is_ge) Compare two character sequences for being greater or equal\n In this version the right-hand side character sequences is by a string. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: lhs type( string_type ), intent(in) :: rhs Return Value logical","tags":"","loc":"interface/operator(.ge.).html"},{"title":"operator(.gt.) â€“ stdlib_string","text":"public interface operator(.gt.) Compare two character sequences for being greater, the left-hand side,\n the right-hand side or both character sequences can be represented by\n a string. This operator is elemental and returns a default logical scalar value. Contents Module Procedures gt_string_string gt_string_char gt_char_string Module Procedures private elemental function gt_string_string(lhs, rhs) result(is_gt) Compare two character sequences for being greater.\n In this version both character sequences are by a string. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: lhs type( string_type ), intent(in) :: rhs Return Value logical private elemental function gt_string_char(lhs, rhs) result(is_gt) Compare two character sequences for being greater.\n In this version the left-hand side character sequences is by a string. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: lhs character(len=*), intent(in) :: rhs Return Value logical private elemental function gt_char_string(lhs, rhs) result(is_gt) Compare two character sequences for being greater.\n In this version the right-hand side character sequences is by a string. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: lhs type( string_type ), intent(in) :: rhs Return Value logical","tags":"","loc":"interface/operator(.gt.).html"},{"title":"operator(.le.) â€“ stdlib_string","text":"public interface operator(.le.) Compare two character sequences for being less than, the left-hand side,\n the right-hand side or both character sequences can be represented by\n a string. This operator is elemental and returns a default logical scalar value. Contents Module Procedures le_string_string le_string_char le_char_string Module Procedures private elemental function le_string_string(lhs, rhs) result(is_le) Compare two character sequences for being less or equal.\n In this version both character sequences are by a string. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: lhs type( string_type ), intent(in) :: rhs Return Value logical private elemental function le_string_char(lhs, rhs) result(is_le) Compare two character sequences for being less or equal.\n In this version the left-hand side character sequences is by a string. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: lhs character(len=*), intent(in) :: rhs Return Value logical private elemental function le_char_string(lhs, rhs) result(is_le) Compare two character sequences for being less or equal\n In this version the right-hand side character sequences is by a string. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: lhs type( string_type ), intent(in) :: rhs Return Value logical","tags":"","loc":"interface/operator(.le.).html"},{"title":"operator(.lt.) â€“ stdlib_string","text":"public interface operator(.lt.) Compare two character sequences for being less, the left-hand side,\n the right-hand side or both character sequences can be represented by\n a string. This operator is elemental and returns a default logical scalar value. Contents Module Procedures lt_string_string lt_string_char lt_char_string Module Procedures private elemental function lt_string_string(lhs, rhs) result(is_lt) Compare two character sequences for being less.\n In this version both character sequences are by a string. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: lhs type( string_type ), intent(in) :: rhs Return Value logical private elemental function lt_string_char(lhs, rhs) result(is_lt) Compare two character sequences for being less.\n In this version the left-hand side character sequences is by a string. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: lhs character(len=*), intent(in) :: rhs Return Value logical private elemental function lt_char_string(lhs, rhs) result(is_lt) Compare two character sequences for being less.\n In this version the right-hand side character sequences is by a string. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: lhs type( string_type ), intent(in) :: rhs Return Value logical","tags":"","loc":"interface/operator(.lt.).html"},{"title":"operator(.ne.) â€“ stdlib_string","text":"public interface operator(.ne.) Compare two character sequences for inequality, the left-hand side,\n the right-hand side or both character sequences can be represented by\n a string. This operator is elemental and returns a default logical scalar value. Contents Module Procedures ne_string_string ne_string_char ne_char_string Module Procedures private elemental function ne_string_string(lhs, rhs) result(is_ne) Compare two character sequences for inequality.\n In this version both character sequences are by a string. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: lhs type( string_type ), intent(in) :: rhs Return Value logical private elemental function ne_string_char(lhs, rhs) result(is_ne) Compare two character sequences for inequality.\n In this version the left-hand side character sequences is by a string. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: lhs character(len=*), intent(in) :: rhs Return Value logical private elemental function ne_char_string(lhs, rhs) result(is_ne) Compare two character sequences for inequality.\n In this version the right-hand side character sequences is by a string. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: lhs type( string_type ), intent(in) :: rhs Return Value logical","tags":"","loc":"interface/operator(.ne.).html"},{"title":"operator(//) â€“ stdlib_string","text":"public interface operator(//) Concatenate two character sequences, the left-hand side, the right-hand side\n or both character sequences can be represented by a string. This operator is elemental and returns a scalar character value. Contents Module Procedures concat_string_string concat_string_char concat_char_string Module Procedures private elemental function concat_string_string(lhs, rhs) result(string) Concatenate two character sequences.\n In this version both character sequences are by a string. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: lhs type( string_type ), intent(in) :: rhs Return Value character(len=len(lhs)+len(rhs)) private elemental function concat_string_char(lhs, rhs) result(string) Concatenate two character sequences.\n In this version the left-hand side character sequences is by a string. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: lhs character(len=*), intent(in) :: rhs Return Value character(len=len(lhs)+len(rhs)) private elemental function concat_char_string(lhs, rhs) result(string) Concatenate two character sequences.\n In this version the right-hand side character sequences is by a string. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: lhs type( string_type ), intent(in) :: rhs Return Value character(len=len(lhs)+len(rhs))","tags":"","loc":"interface/operator(SLASHSLASH).html"},{"title":"read(formatted) â€“ stdlib_string","text":"public interface read(formatted) Read a character sequence from a connected unformatted unit into the string. Contents Module Procedures read_formatted Module Procedures private subroutine read_formatted(string, unit, iotype, v_list, iostat, iomsg) Read a character sequence from a connected formatted unit into the string. Arguments Type Intent Optional Attributes Name type( string_type ), intent(inout) :: string integer, intent(in) :: unit character(len=*), intent(in) :: iotype integer, intent(in) :: v_list (:) integer, intent(out) :: iostat character(len=*), intent(inout) :: iomsg","tags":"","loc":"interface/read(formatted).html"},{"title":"read(unformatted) â€“ stdlib_string","text":"public interface read(unformatted) Read a character sequence from a connected unformatted unit into the string. Contents Module Procedures read_unformatted Module Procedures private subroutine read_unformatted(string, unit, iostat, iomsg) Read a character sequence from a connected unformatted unit into the string. Arguments Type Intent Optional Attributes Name type( string_type ), intent(inout) :: string integer, intent(in) :: unit integer, intent(out) :: iostat character(len=*), intent(inout) :: iomsg","tags":"","loc":"interface/read(unformatted).html"},{"title":"repeat â€“ stdlib_string","text":"public interface repeat Repeats the character sequence hold by the string by the number of\n specified copies. This method is elemental and returns a scalar character value. Contents Module Procedures repeat_string Module Procedures private elemental function repeat_string(string, ncopies) result(repeated_string) Repeats the character sequence hold by the string by the number of\n specified copies. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string integer, intent(in) :: ncopies Return Value character(len=len(string)*ncopies)","tags":"","loc":"interface/repeat.html"},{"title":"scan â€“ stdlib_string","text":"public interface scan Scan a string for the presence of a set of characters. Scans a string for\n any of the characters in a set of characters. If back is either absent or false , this function returns the position\n of the leftmost character of string that is in set . If back is true ,\n the rightmost position is returned. If no character of set is found in string , the result is zero. This method is elemental and returns a default integer scalar value. Contents Module Procedures scan_string_string scan_string_char scan_char_string Module Procedures private elemental function scan_string_string(string, set, back) result(pos) Scan a character sequence for any of the characters in a set of characters.\n In this version both the character sequence and the character set are\n represented by a string. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string type( string_type ), intent(in) :: set logical, intent(in), optional :: back Return Value integer private elemental function scan_string_char(string, set, back) result(pos) Scan a character sequence for any of the characters in a set of characters.\n In this version the character sequences is represented by a string. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string character(len=*), intent(in) :: set logical, intent(in), optional :: back Return Value integer private elemental function scan_char_string(string, set, back) result(pos) Scan a character sequence for any of the characters in a set of characters.\n In this version the set of characters is represented by a string. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string type( string_type ), intent(in) :: set logical, intent(in), optional :: back Return Value integer","tags":"","loc":"interface/scan.html"},{"title":"string_type â€“ stdlib_string","text":"public interface string_type Constructor for new string instances Contents Module Procedures new_string new_string_from_chars Module Procedures private elemental function new_string(string) result(new) Constructor for new string instances from a scalar character value. Arguments Type Intent Optional Attributes Name character(len=*), intent(in), optional :: string Return Value type( string_type ) private pure function new_string_from_chars(chars) result(new) Constructor for new string instances from an array of characters. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: chars (:) Return Value type( string_type )","tags":"","loc":"interface/string_type.html"},{"title":"trim â€“ stdlib_string","text":"public interface trim Returns the character sequence hold by the string without trailing spaces. This method is elemental and returns a scalar character value. Contents Module Procedures trim_string Module Procedures private elemental function trim_string(string) result(trimmed_string) Returns the character sequence hold by the string without trailing spaces. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string Return Value character(len=len_trim(string))","tags":"","loc":"interface/trim.html"},{"title":"verify â€“ stdlib_string","text":"public interface verify Scan a string for the absence of a set of characters. Verifies that all\n the characters in string belong to the set of characters in set. If back is either absent or false , this function returns the position\n of the leftmost character of string that is not in set . If back is true ,\n the rightmost position is returned. If all characters of string are found\n in set , the result is zero. This method is elemental and returns a default integer scalar value. Contents Module Procedures verify_string_string verify_string_char verify_char_string Module Procedures private elemental function verify_string_string(string, set, back) result(pos) Verify a character sequence for the absence any of the characters in\n a set of characters. In this version both the character sequence and\n the character set are represented by a string. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string type( string_type ), intent(in) :: set logical, intent(in), optional :: back Return Value integer private elemental function verify_string_char(string, set, back) result(pos) Verify a character sequence for the absence any of the characters in\n a set of characters. In this version the character sequences is\n represented by a string. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string character(len=*), intent(in) :: set logical, intent(in), optional :: back Return Value integer private elemental function verify_char_string(string, set, back) result(pos) Verify a character sequence for the absence any of the characters in\n a set of characters. In this version the set of characters is\n represented by a string. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string type( string_type ), intent(in) :: set logical, intent(in), optional :: back Return Value integer","tags":"","loc":"interface/verify.html"},{"title":"write(formatted) â€“ stdlib_string","text":"public interface write(formatted) Write the character sequence hold by the string to a connected formatted\n unit. Contents Module Procedures write_formatted Module Procedures private subroutine write_formatted(string, unit, iotype, v_list, iostat, iomsg) Write the character sequence hold by the string to a connected formatted\n unit. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string integer, intent(in) :: unit character(len=*), intent(in) :: iotype integer, intent(in) :: v_list (:) integer, intent(out) :: iostat character(len=*), intent(inout) :: iomsg","tags":"","loc":"interface/write(formatted).html"},{"title":"write(unformatted) â€“ stdlib_string","text":"public interface write(unformatted) Write the character sequence hold by the string to a connected unformatted\n unit. Contents Module Procedures write_unformatted Module Procedures private subroutine write_unformatted(string, unit, iostat, iomsg) Write the character sequence hold by the string to a connected unformatted\n unit. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string integer, intent(in) :: unit integer, intent(out) :: iostat character(len=*), intent(inout) :: iomsg","tags":"","loc":"interface/write(unformatted).html"},{"title":"stdlib_string_type â€“ stdlib_string","text":"Implementation of a string type to hold an arbitrary sequence of characters. This module provides string type compatible with all Fortran instrinsic character\n procedures as well as overloaded operators for working with character variables. A string type can be easily constructed by creating a new instance from a\n character variable or literal by invoking its constructor or by assigning it\n to a string type. Generally, the string type behaves similar to a deferred\n length character in most regards but adds memory access safety. The specification of this module is available here . Contents Interfaces adjustl adjustr assignment(=) char iachar ichar index len len_trim lge lgt lle llt operator(.eq.) operator(.ge.) operator(.gt.) operator(.le.) operator(.lt.) operator(.ne.) operator(//) read(formatted) read(unformatted) repeat scan string_type trim verify write(formatted) write(unformatted) Derived Types string_type Interfaces public interface adjustl Left-adjust the character sequence represented by the string.\n The length of the character sequence remains unchanged. Read moreâ€¦ private elemental function adjustl_string(string) result(adjusted_string) Left-adjust the character sequence represented by the string.\n The length of the character sequence remains unchanged. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string Return Value character(len=len(string)) public interface adjustr Right-adjust the character sequence represented by the string.\n The length of the character sequence remains unchanged. Read moreâ€¦ private elemental function adjustr_string(string) result(adjusted_string) Right-adjust the character sequence represented by the string.\n The length of the character sequence remains unchanged. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string Return Value character(len=len(string)) public interface assignment(=) Assign a character sequence to a string. private elemental subroutine assign_string_char(lhs, rhs) Assign a character sequence to a string. Arguments Type Intent Optional Attributes Name type( string_type ), intent(inout) :: lhs character(len=*), intent(in) :: rhs private pure subroutine assign_string_chars(lhs, rhs) Assign a character sequence to a string. Arguments Type Intent Optional Attributes Name type( string_type ), intent(inout) :: lhs character(len=*), intent(in) :: rhs (:) public interface char Return the character sequence represented by the string. Read moreâ€¦ private elemental function char_string(string) result(character_string) Return the character sequence represented by the string. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string Return Value character(len=len(string)) private elemental function char_string_pos(string, pos) result(character_string) Return the character sequence represented by the string. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string integer, intent(in) :: pos Return Value character(len=1) private elemental function char_string_range(string, start, last) result(character_string) Return the character sequence represented by the string. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string integer, intent(in) :: start integer, intent(in) :: last Return Value character(len=max(last-start+1,0)) public interface iachar Code in ASCII collating sequence. Read moreâ€¦ private elemental function iachar_string(string) result(ich) Code in ASCII collating sequence. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string Return Value integer public interface ichar Character-to-integer conversion function. Read moreâ€¦ private elemental function ichar_string(string) result(ich) Character-to-integer conversion function. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string Return Value integer public interface index Position of a substring within a string . Read moreâ€¦ private elemental function index_string_string(string, substring, back) result(pos) Position of a sequence of character within a character sequence.\n In this version both character sequences are represented by a string. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string type( string_type ), intent(in) :: substring logical, intent(in), optional :: back Return Value integer private elemental function index_string_char(string, substring, back) result(pos) Position of a sequence of character within a character sequence.\n In this version the main character sequence is represented by a string. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string character(len=*), intent(in) :: substring logical, intent(in), optional :: back Return Value integer private elemental function index_char_string(string, substring, back) result(pos) Position of a sequence of character within a character sequence.\n In this version the sub character sequence is represented by a string. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string type( string_type ), intent(in) :: substring logical, intent(in), optional :: back Return Value integer public interface len Returns the length of the character sequence represented by the string. Read moreâ€¦ private elemental function len_string(string) result(length) Returns the length of the character sequence represented by the string. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string Return Value integer public interface len_trim Returns the length of the character sequence without trailing spaces\n represented by the string. Read moreâ€¦ private elemental function len_trim_string(string) result(length) Returns the length of the character sequence without trailing spaces\n represented by the string. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string Return Value integer public interface lge Lexically compare the order of two character sequences being greater equal,\n The left-hand side, the right-hand side or both character sequences can\n be represented by a string. Read moreâ€¦ private elemental function lge_string_string(lhs, rhs) result(is_lge) Lexically compare two character sequences for being greater or equal.\n In this version both character sequences are by a string. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: lhs type( string_type ), intent(in) :: rhs Return Value logical private elemental function lge_string_char(lhs, rhs) result(is_lge) Lexically compare two character sequences for being greater or equal.\n In this version the left-hand side character sequences is by a string. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: lhs character(len=*), intent(in) :: rhs Return Value logical private elemental function lge_char_string(lhs, rhs) result(is_lge) Lexically compare two character sequences for being greater or equal\n In this version the right-hand side character sequences is by a string. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: lhs type( string_type ), intent(in) :: rhs Return Value logical public interface lgt Lexically compare the order of two character sequences being greater,\n The left-hand side, the right-hand side or both character sequences can\n be represented by a string. Read moreâ€¦ private elemental function lgt_string_string(lhs, rhs) result(is_lgt) Lexically compare two character sequences for being greater.\n In this version both character sequences are by a string. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: lhs type( string_type ), intent(in) :: rhs Return Value logical private elemental function lgt_string_char(lhs, rhs) result(is_lgt) Lexically compare two character sequences for being greater.\n In this version the left-hand side character sequences is by a string. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: lhs character(len=*), intent(in) :: rhs Return Value logical private elemental function lgt_char_string(lhs, rhs) result(is_lgt) Lexically compare two character sequences for being greater.\n In this version the right-hand side character sequences is by a string. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: lhs type( string_type ), intent(in) :: rhs Return Value logical public interface lle Lexically compare the order of two character sequences being less equal,\n The left-hand side, the right-hand side or both character sequences can\n be represented by a string. Read moreâ€¦ private elemental function lle_string_string(lhs, rhs) result(is_lle) Lexically compare two character sequences for being less or equal.\n In this version both character sequences are by a string. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: lhs type( string_type ), intent(in) :: rhs Return Value logical private elemental function lle_string_char(lhs, rhs) result(is_lle) Lexically compare two character sequences for being less or equal.\n In this version the left-hand side character sequences is by a string. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: lhs character(len=*), intent(in) :: rhs Return Value logical private elemental function lle_char_string(lhs, rhs) result(is_lle) Lexically compare two character sequences for being less or equal\n In this version the right-hand side character sequences is by a string. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: lhs type( string_type ), intent(in) :: rhs Return Value logical public interface llt Lexically compare the order of two character sequences being less,\n The left-hand side, the right-hand side or both character sequences can\n be represented by a string. Read moreâ€¦ private elemental function llt_string_string(lhs, rhs) result(is_llt) Lexically compare two character sequences for being less.\n In this version both character sequences are by a string. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: lhs type( string_type ), intent(in) :: rhs Return Value logical private elemental function llt_string_char(lhs, rhs) result(is_llt) Lexically compare two character sequences for being less.\n In this version the left-hand side character sequences is by a string. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: lhs character(len=*), intent(in) :: rhs Return Value logical private elemental function llt_char_string(lhs, rhs) result(is_llt) Lexically compare two character sequences for being less.\n In this version the right-hand side character sequences is by a string. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: lhs type( string_type ), intent(in) :: rhs Return Value logical public interface operator(.eq.) Compare two character sequences for equality, the left-hand side,\n the right-hand side or both character sequences can be represented by\n a string. Read moreâ€¦ private elemental function eq_string_string(lhs, rhs) result(is_eq) Compare two character sequences for equality.\n In this version both character sequences are by a string. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: lhs type( string_type ), intent(in) :: rhs Return Value logical private elemental function eq_string_char(lhs, rhs) result(is_eq) Compare two character sequences for equality.\n In this version the left-hand side character sequences is by a string. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: lhs character(len=*), intent(in) :: rhs Return Value logical private elemental function eq_char_string(lhs, rhs) result(is_eq) Compare two character sequences for equality.\n In this version the right-hand side character sequences is by a string. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: lhs type( string_type ), intent(in) :: rhs Return Value logical public interface operator(.ge.) Compare two character sequences for being greater than, the left-hand side,\n the right-hand side or both character sequences can be represented by\n a string. Read moreâ€¦ private elemental function ge_string_string(lhs, rhs) result(is_ge) Compare two character sequences for being greater or equal.\n In this version both character sequences are by a string. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: lhs type( string_type ), intent(in) :: rhs Return Value logical private elemental function ge_string_char(lhs, rhs) result(is_ge) Compare two character sequences for being greater or equal.\n In this version the left-hand side character sequences is by a string. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: lhs character(len=*), intent(in) :: rhs Return Value logical private elemental function ge_char_string(lhs, rhs) result(is_ge) Compare two character sequences for being greater or equal\n In this version the right-hand side character sequences is by a string. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: lhs type( string_type ), intent(in) :: rhs Return Value logical public interface operator(.gt.) Compare two character sequences for being greater, the left-hand side,\n the right-hand side or both character sequences can be represented by\n a string. Read moreâ€¦ private elemental function gt_string_string(lhs, rhs) result(is_gt) Compare two character sequences for being greater.\n In this version both character sequences are by a string. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: lhs type( string_type ), intent(in) :: rhs Return Value logical private elemental function gt_string_char(lhs, rhs) result(is_gt) Compare two character sequences for being greater.\n In this version the left-hand side character sequences is by a string. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: lhs character(len=*), intent(in) :: rhs Return Value logical private elemental function gt_char_string(lhs, rhs) result(is_gt) Compare two character sequences for being greater.\n In this version the right-hand side character sequences is by a string. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: lhs type( string_type ), intent(in) :: rhs Return Value logical public interface operator(.le.) Compare two character sequences for being less than, the left-hand side,\n the right-hand side or both character sequences can be represented by\n a string. Read moreâ€¦ private elemental function le_string_string(lhs, rhs) result(is_le) Compare two character sequences for being less or equal.\n In this version both character sequences are by a string. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: lhs type( string_type ), intent(in) :: rhs Return Value logical private elemental function le_string_char(lhs, rhs) result(is_le) Compare two character sequences for being less or equal.\n In this version the left-hand side character sequences is by a string. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: lhs character(len=*), intent(in) :: rhs Return Value logical private elemental function le_char_string(lhs, rhs) result(is_le) Compare two character sequences for being less or equal\n In this version the right-hand side character sequences is by a string. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: lhs type( string_type ), intent(in) :: rhs Return Value logical public interface operator(.lt.) Compare two character sequences for being less, the left-hand side,\n the right-hand side or both character sequences can be represented by\n a string. Read moreâ€¦ private elemental function lt_string_string(lhs, rhs) result(is_lt) Compare two character sequences for being less.\n In this version both character sequences are by a string. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: lhs type( string_type ), intent(in) :: rhs Return Value logical private elemental function lt_string_char(lhs, rhs) result(is_lt) Compare two character sequences for being less.\n In this version the left-hand side character sequences is by a string. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: lhs character(len=*), intent(in) :: rhs Return Value logical private elemental function lt_char_string(lhs, rhs) result(is_lt) Compare two character sequences for being less.\n In this version the right-hand side character sequences is by a string. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: lhs type( string_type ), intent(in) :: rhs Return Value logical public interface operator(.ne.) Compare two character sequences for inequality, the left-hand side,\n the right-hand side or both character sequences can be represented by\n a string. Read moreâ€¦ private elemental function ne_string_string(lhs, rhs) result(is_ne) Compare two character sequences for inequality.\n In this version both character sequences are by a string. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: lhs type( string_type ), intent(in) :: rhs Return Value logical private elemental function ne_string_char(lhs, rhs) result(is_ne) Compare two character sequences for inequality.\n In this version the left-hand side character sequences is by a string. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: lhs character(len=*), intent(in) :: rhs Return Value logical private elemental function ne_char_string(lhs, rhs) result(is_ne) Compare two character sequences for inequality.\n In this version the right-hand side character sequences is by a string. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: lhs type( string_type ), intent(in) :: rhs Return Value logical public interface operator(//) Concatenate two character sequences, the left-hand side, the right-hand side\n or both character sequences can be represented by a string. Read moreâ€¦ private elemental function concat_string_string(lhs, rhs) result(string) Concatenate two character sequences.\n In this version both character sequences are by a string. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: lhs type( string_type ), intent(in) :: rhs Return Value character(len=len(lhs)+len(rhs)) private elemental function concat_string_char(lhs, rhs) result(string) Concatenate two character sequences.\n In this version the left-hand side character sequences is by a string. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: lhs character(len=*), intent(in) :: rhs Return Value character(len=len(lhs)+len(rhs)) private elemental function concat_char_string(lhs, rhs) result(string) Concatenate two character sequences.\n In this version the right-hand side character sequences is by a string. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: lhs type( string_type ), intent(in) :: rhs Return Value character(len=len(lhs)+len(rhs)) public interface read(formatted) Read a character sequence from a connected unformatted unit into the string. private subroutine read_formatted(string, unit, iotype, v_list, iostat, iomsg) Read a character sequence from a connected formatted unit into the string. Arguments Type Intent Optional Attributes Name type( string_type ), intent(inout) :: string integer, intent(in) :: unit character(len=*), intent(in) :: iotype integer, intent(in) :: v_list (:) integer, intent(out) :: iostat character(len=*), intent(inout) :: iomsg public interface read(unformatted) Read a character sequence from a connected unformatted unit into the string. private subroutine read_unformatted(string, unit, iostat, iomsg) Read a character sequence from a connected unformatted unit into the string. Arguments Type Intent Optional Attributes Name type( string_type ), intent(inout) :: string integer, intent(in) :: unit integer, intent(out) :: iostat character(len=*), intent(inout) :: iomsg public interface repeat Repeats the character sequence hold by the string by the number of\n specified copies. Read moreâ€¦ private elemental function repeat_string(string, ncopies) result(repeated_string) Repeats the character sequence hold by the string by the number of\n specified copies. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string integer, intent(in) :: ncopies Return Value character(len=len(string)*ncopies) public interface scan Scan a string for the presence of a set of characters. Scans a string for\n any of the characters in a set of characters. Read moreâ€¦ private elemental function scan_string_string(string, set, back) result(pos) Scan a character sequence for any of the characters in a set of characters.\n In this version both the character sequence and the character set are\n represented by a string. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string type( string_type ), intent(in) :: set logical, intent(in), optional :: back Return Value integer private elemental function scan_string_char(string, set, back) result(pos) Scan a character sequence for any of the characters in a set of characters.\n In this version the character sequences is represented by a string. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string character(len=*), intent(in) :: set logical, intent(in), optional :: back Return Value integer private elemental function scan_char_string(string, set, back) result(pos) Scan a character sequence for any of the characters in a set of characters.\n In this version the set of characters is represented by a string. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string type( string_type ), intent(in) :: set logical, intent(in), optional :: back Return Value integer public interface string_type Constructor for new string instances private elemental function new_string(string) result(new) Constructor for new string instances from a scalar character value. Arguments Type Intent Optional Attributes Name character(len=*), intent(in), optional :: string Return Value type( string_type ) private pure function new_string_from_chars(chars) result(new) Constructor for new string instances from an array of characters. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: chars (:) Return Value type( string_type ) public interface trim Returns the character sequence hold by the string without trailing spaces. Read moreâ€¦ private elemental function trim_string(string) result(trimmed_string) Returns the character sequence hold by the string without trailing spaces. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string Return Value character(len=len_trim(string)) public interface verify Scan a string for the absence of a set of characters. Verifies that all\n the characters in string belong to the set of characters in set. Read moreâ€¦ private elemental function verify_string_string(string, set, back) result(pos) Verify a character sequence for the absence any of the characters in\n a set of characters. In this version both the character sequence and\n the character set are represented by a string. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string type( string_type ), intent(in) :: set logical, intent(in), optional :: back Return Value integer private elemental function verify_string_char(string, set, back) result(pos) Verify a character sequence for the absence any of the characters in\n a set of characters. In this version the character sequences is\n represented by a string. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string character(len=*), intent(in) :: set logical, intent(in), optional :: back Return Value integer private elemental function verify_char_string(string, set, back) result(pos) Verify a character sequence for the absence any of the characters in\n a set of characters. In this version the set of characters is\n represented by a string. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string type( string_type ), intent(in) :: set logical, intent(in), optional :: back Return Value integer public interface write(formatted) Write the character sequence hold by the string to a connected formatted\n unit. private subroutine write_formatted(string, unit, iotype, v_list, iostat, iomsg) Write the character sequence hold by the string to a connected formatted\n unit. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string integer, intent(in) :: unit character(len=*), intent(in) :: iotype integer, intent(in) :: v_list (:) integer, intent(out) :: iostat character(len=*), intent(inout) :: iomsg public interface write(unformatted) Write the character sequence hold by the string to a connected unformatted\n unit. private subroutine write_unformatted(string, unit, iostat, iomsg) Write the character sequence hold by the string to a connected unformatted\n unit. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string integer, intent(in) :: unit integer, intent(out) :: iostat character(len=*), intent(inout) :: iomsg Derived Types type, public, sequence  :: string_type String type holding an arbitrary sequence of characters. Constructor Constructor for new string instances private elemental function new_string (string) Constructor for new string instances from a scalar character value. private pure function new_string_from_chars (chars) Constructor for new string instances from an array of characters.","tags":"","loc":"module/stdlib_string_type.html"},{"title":"Specifications â€“ stdlib_string","text":"","tags":"","loc":"page//index.html"},{"title":"Specifications â€“ stdlib_string","text":"Experimental Features & Modules Experimental Features & Modules string_type - Functional string type","tags":"","loc":"page/specs/index.html"},{"title":"string type â€“ stdlib_string","text":"The stdlib_string_type module The stdlib_string_type module Introduction Derived types provided The string_type derived type Status Procedures and methods provided Constructor for empty string Description Syntax Status Class Argument Result value Example Constructor from character scalar Description Syntax Status Class Argument Result value Example Constructor from character array Description Syntax Status Class Argument Result value Example Assignment of character scalar Description Syntax Status Class Example Assignment of character array Description Syntax Status Class Example Len function Description Syntax Status Class Argument Result value Example Len_trim function Description Syntax Status Class Argument Result value Example Trim function Description Syntax Status Class Argument Result value Example Adjustl function Description Syntax Status Class Argument Result value Example Adjustr function Description Syntax Status Class Argument Result value Example Repeat function Description Syntax Status Class Argument Result value Example Char function Description Syntax Status Class Argument Result value Example Char function (position variant) Description Syntax Status Class Argument Result value Example Char function (range variant) Description Syntax Status Class Argument Result value Example Ichar function Description Syntax Status Class Argument Result value Example Iachar function Description Syntax Status Class Argument Result value Example Index function Description Syntax Status Class Argument Result value Example Scan function Description Syntax Status Class Argument Result value Example Verify function Description Syntax Status Class Argument Result value Example Lgt function (lexical greater) Description Syntax Status Class Argument Result value Example Llt function (lexical less) Description Syntax Status Class Argument Result value Example Lge function (lexical greater or equal) Description Syntax Status Class Argument Result value Example Lle function (lexical less or equal) Description Syntax Status Class Argument Result value Example Comparison operator greater Description Syntax Status Class Argument Result value Example Comparison operator less Description Syntax Status Class Argument Result value Example Comparison operator greater or equal Description Syntax Status Class Argument Result value Example Comparison operator less or equal Description Syntax Status Class Argument Result value Example Comparison operator equal Description Syntax Status Class Argument Result value Example Comparison operator not equal Description Syntax Status Class Argument Result value Example Concatenation operator Description Syntax Status Class Argument Result value Example Unformatted write Description Syntax Status Class Argument Example Formatted write Description Syntax Status Class Argument Example Unformatted read Description Syntax Status Class Argument Example Formatted read Description Syntax Status Class Argument Example Introduction The stdlib_string_type provides a derived type holding an arbitrary sequence\nof characters compatible with most Fortran intrinsic character procedures as\nwell as operators for working with character variables and constants. Derived types provided The string_type derived type The string_type is defined as a non-extenable derived type representing a\nsequence of characters. The internal representation of the character sequence\nis implementation dependent and not visible for the user of the module. Status Experimental Procedures and methods provided Constructor for empty string The module defines a default constructor to create an empty string type. Description Creates a string instance representing an empty string. Syntax res = [[stdlib_string_type(module)::string_type(type)]] () Status Experimental Class Elemental function. Argument None. Result value The result is an instance of string_type . Example use stdlib_string_type implicit none type ( string_type ) :: string string = string_type () ! len(string) == 0 end Constructor from character scalar The module defines a default constructor to create a string type\nfrom a character scalar. Description Creates a string instance representing the input character scalar value.\nThe constructor shall create an empty string if an unallocated deferred-length\ncharacter variable is passed. Syntax res = [[stdlib_string_type(module)::string_type(interface)]] (string) Status Experimental Class Elemental function. Argument string : shall be a scalar character value. It is an intent(in) argument. Result value The result is an instance of string_type . Example use stdlib_string_type implicit none type ( string_type ) :: string string = string_type ( \"Sequence\" ) ! len(string) == 8 string = string_type ( \" S p a c e d \" ) ! len(string) == 9 end Constructor from character array The module defines a default constructor to create a string type\nfrom an array of characters. The character array is flattend. Description Creates a string instance representing the flattend input array of characters. Syntax res = [[stdlib_string_type(module)::string_type(interface)]] (chars) Status Experimental Class Pure function. Argument chars : shall be an array of characters. It is an intent(in) argument. Result value The result is an instance of string_type . Example use stdlib_string_type implicit none type ( string_type ) :: string string = string_type ([ \"S\" , \"e\" , \"q\" , \"u\" , \"e\" , \"n\" , \"c\" , \"e\" ]) ! len(string) == 8 end use stdlib_string_type implicit none type ( string_type ) :: string string = string_type ([ \"S\" , \"e\" , \"q\" , \"u\" , \"e\" , \"n\" , \"c\" , \"e\" ]) ! len(string) == 8 end Assignment of character scalar The module defines an assignment operations, = , to create a string type\nfrom a character scalar. Description Creates a string instance representing the right-hand-side character scalar value. Syntax lhs = rhs Status Experimental Class Elemntal subroutine, assignment(=) . Example use stdlib_string_type implicit none type ( string_type ) :: string ! len(string) == 0 string = \"Sequence\" ! len(string) == 8 end Assignment of character array The module defines an assignment operations, = , to create a string type\nfrom an array of characters Description Creates a string instance representing the flattend right-hand-side array of characters. Syntax lhs = rhs Status Experimental Class Pure subroutine, assignment(=) . Example use stdlib_string_type implicit none type ( string_type ) :: string ! len(string) == 0 string = [ \"S\" , \"e\" , \"q\" , \"u\" , \"e\" , \"n\" , \"c\" , \"e\" ] ! len(string) == 8 end Len function Description Returns the length of the character sequence represented by the string. Syntax res = len (string) Status Experimental Class Elemental function. Argument string : Instance of a string_type . This argument is intent(in) . Result value The result is a default integer scalar value. Example use stdlib_string_type implicit none type ( string_type ) :: string integer :: length string = \"Some longer sentence for this example.\" length = len ( string ) ! length == 38 string = \"Whitespace                            \" length = len ( string ) ! length == 38 end Len_trim function Description Returns the length of the character sequence without trailing spaces\nrepresented by the string. Syntax res = len_trim (string) Status Experimental Class Elemental function. Argument string : Instance of a string_type . This argument is intent(in) . Result value The result is a default integer scalar value. Example use stdlib_string_type implicit none type ( string_type ) :: string integer :: length string = \"Some longer sentence for this example.\" length = len_trim ( string ) ! length == 38 string = \"Whitespace                            \" length = len_trim ( string ) ! length == 10 end Trim function Description Returns the character sequence hold by the string without trailing spaces. Syntax res = trim (string) Status Experimental Class Elemental function. Argument string : Instance of a string_type . This argument is intent(in) . Result value The result is a scalar character value of the same or less length as the character\nsequence represented by the input string_type instance. Example use stdlib_string_type implicit none type ( string_type ) :: string character ( len = :), allocatable :: dlc string = \"Whitespace                            \" dlc = trim ( string ) ! len(dlc) == 10 end Adjustl function Description Left-adjust the character sequence represented by the string.\nThe length of the character sequence remains unchanged. Syntax res = adjustl (string) Status Experimental Class Elemental function. Argument string : Instance of a string_type . This argument is intent(in) . Result value The result is a scalar character value of the same length as the character sequence\nrepresented by the input string_type instance. Example use stdlib_string_type implicit none type ( string_type ) :: string string = \"                            Whitespace\" string = adjustl ( string ) ! char(string) == \"Whitespace                            \" end Adjustr function Description Right-adjust the character sequence represented by the string.\nThe length of the character sequence remains unchanged. Syntax res = adjustr (string) Status Experimental Class Elemental function. Argument string : Instance of a string_type . This argument is intent(in) . Result value The result is a scalar character value of the same length as the character sequence\nrepresented by the input string_type instance. Example use stdlib_string_type implicit none type ( string_type ) :: string string = \"Whitespace                            \" string = adjustr ( string ) ! char(string) == \"                            Whitespace\" end Repeat function Description Repeats the character sequence hold by the string by the number of\nspecified copies. Syntax res = repeat (string, ncopies) Status Experimental Class Elemental function. Argument string : Instance of a string_type . This argument is intent(in) . ncopies : Integer of default type. This argument is intent(in) . Result value The result is a scalar character value. Example use stdlib_string_type implicit none type ( string_type ) :: string character ( len = :), allocatable :: dlc string = \"What? \" dlc = repeat ( string , 3 ) ! dlc == \"What? What? What? \" end Char function Description Return the character sequence represented by the string. Syntax res = char (string) Status Experimental Class Elemental function. Argument string : Instance of a string_type . This argument is intent(in) . Result value The result is a scalar character value. Example use stdlib_string_type implicit none type ( string_type ) :: string character ( len = :), allocatable :: dlc string = \"Character sequence\" dlc = char ( string ) ! dlc == \"Character sequence\" end Char function (position variant) Description Return the character sequence represented by the string. Syntax res = char (string, pos) Status Experimental Class Elemental function. Argument string : Instance of a string_type . This argument is intent(in) . pos : Integer of default type. This argument is intent(in) . Result value The result is a scalar character value. Example use stdlib_string_type implicit none type ( string_type ) :: string character ( len = :), allocatable :: dlc character ( len = 1 ), allocatable :: chars (:) string = \"Character sequence\" dlc = char ( string , 3 ) ! dlc == \"a\" chars = char ( string , [ 3 , 5 , 8 , 12 , 14 , 15 , 18 ]) ! chars == [\"a\", \"a\", \"e\", \"e\", \"u\", \"e\", \"e\"] end Char function (range variant) Description Return the character sequence represented by the string. Syntax res = char (string, start, last) Status Experimental Class Elemental function. Argument string : Instance of a string_type . This argument is intent(in) . start : Integer of default type. This argument is intent(in) . last : Integer of default type. This argument is intent(in) . Result value The result is a scalar character value. Example use stdlib_string_type implicit none type ( string_type ) :: string character ( len = :), allocatable :: dlc string = \"Fortran\" dlc = char ( string , 1 , 4 ) ! dlc == \"Fort\" end Ichar function Character-to-integer conversion function. Description Returns the code for the character in the first character position of the\ncharacter sequence in the system's native character set. Syntax res = ichar (string) Status Experimental Class Elemental function. Argument string : Instance of a string_type . This argument is intent(in) . Result value The result is a default integer scalar value. Example use stdlib_string_type implicit none type ( string_type ) :: string integer :: code string = \"Fortran\" code = ichar ( string ) end Iachar function Code in ASCII collating sequence. Description Returns the code for the ASCII character in the first character position of\nthe character sequences represent by the string. Syntax res = iachar (string) Status Experimental Class Elemental function. Argument string : Instance of a string_type . This argument is intent(in) . Result value The result is a default integer scalar value. Example use stdlib_string_type implicit none type ( string_type ) :: string integer :: code string = \"Fortran\" code = iachar ( string ) end Index function Position of a substring within a string . Description Returns the position of the start of the leftmost or rightmost occurrence\nof string substring in string , counting from one. If substring is not\npresent in string , zero is returned. Syntax res = index (string, substring[, back]) Status Experimental Class Elemental function. Argument string : Either scalar character value or string type. This argument is intent(in) . substring : Either scalar character value or string type. This argument is intent(in) . back : Either absent or a scalar logical value. This argument is intent(in) . Result value The result is a default integer scalar value. Example use stdlib_string_type implicit none type ( string_type ) :: string integer :: pos string = \"Search this string for this expression\" pos = index ( string , \"this\" ) ! pos == 8 pos = index ( string , \"this\" , back = . true .) ! pos == 24 pos = index ( string , \"This\" ) ! pos == 0 end Scan function Scan a string for the presence of a set of characters. Scans a string for\nany of the characters in a set of characters. Description If back is either absent or false , this function returns the position\nof the leftmost character of string that is in set . If back is true ,\nthe rightmost position is returned. If no character of set is found in string , the result is zero. Syntax res = scan (string, set[, back]) Status Experimental Class Elemental function. Argument string : Either scalar character value or string type. This argument is intent(in) . set : Either scalar character value or string type. This argument is intent(in) . back : Either absent or a scalar logical value. This argument is intent(in) . Result value The result is a default integer scalar value. Example use stdlib_string_type implicit none type ( string_type ) :: string integer :: pos string = \"fortran\" pos = scan ( string , \"ao\" ) ! pos == 2 pos = scan ( string , \"ao\" , . true .) ! pos == 6 pos = scan ( string , \"c++\" ) ! pos == 0 end Verify function Scan a string for the absence of a set of characters. Verifies that all\nthe characters in string belong to the set of characters in set. Description If back is either absent or false , this function returns the position\nof the leftmost character of string that is not in set . If back is true ,\nthe rightmost position is returned. If all characters of string are found\nin set , the result is zero. Syntax res = verify (string, set[, back]) Status Experimental Class Elemental function. Argument string : Either scalar character value or string type. This argument is intent(in) . set : Either scalar character value or string type. This argument is intent(in) . back : Either absent or a scalar logical value. This argument is intent(in) . Result value The result is a default integer scalar value. Example use stdlib_string_type implicit none type ( string_type ) :: string integer :: pos string = \"fortran\" pos = verify ( string , \"ao\" ) ! pos == 1 pos = verify ( string , \"fo\" ) ! pos == 3 pos = verify ( string , \"c++\" ) ! pos == 1 pos = verify ( string , \"c++\" , back = . true .) ! pos == 7 pos = verify ( string , string ) ! pos == 0 end Lgt function (lexical greater) Lexically compare the order of two character sequences being greater. Description The left-hand side, the right-hand side or both character sequences can\nbe represented by a string type.\nThis defines three procedures overloading the intrinsic lgt procedure. Syntax res = lgt (lhs, rhs) Status Experimental Class Elemental function. Argument lhs : Either scalar character value or string type. This argument is intent(in) . rhs : Either scalar character value or string type. This argument is intent(in) . Result value The result is a default logical scalar value. Example use stdlib_string_type implicit none type ( string_type ) :: string logical :: res string = \"bcd\" res = lgt ( string , \"abc\" ) ! res .eqv. .true. res = lgt ( string , \"bcd\" ) ! res .eqv. .false. res = lgt ( string , \"cde\" ) ! res .eqv. .false. end Llt function (lexical less) Lexically compare the order of two character sequences being less. Description The left-hand side, the right-hand side or both character sequences can\nbe represented by a string type.\nThis defines three procedures overloading the intrinsic llt procedure. Syntax res = llt (lhs, rhs) Status Experimental Class Elemental function. Argument lhs : Either scalar character value or string type. This argument is intent(in) . rhs : Either scalar character value or string type. This argument is intent(in) . Result value The result is a default logical scalar value. Example use stdlib_string_type implicit none type ( string_type ) :: string logical :: res string = \"bcd\" res = llt ( string , \"abc\" ) ! res .eqv. .false. res = llt ( string , \"bcd\" ) ! res .eqv. .false. res = llt ( string , \"cde\" ) ! res .eqv. .true. end Lge function (lexical greater or equal) Lexically compare the order of two character sequences being greater or equal. Description The left-hand side, the right-hand side or both character sequences can\nbe represented by a string type.\nThis defines three procedures overloading the intrinsic lge procedure. Syntax res = lge (lhs, rhs) Status Experimental Class Elemental function. Argument lhs : Either scalar character value or string type. This argument is intent(in) . rhs : Either scalar character value or string type. This argument is intent(in) . Result value The result is a default logical scalar value. Example use stdlib_string_type implicit none type ( string_type ) :: string logical :: res string = \"bcd\" res = lge ( string , \"abc\" ) ! res .eqv. .true. res = lge ( string , \"bcd\" ) ! res .eqv. .true. res = lge ( string , \"cde\" ) ! res .eqv. .false. end Lle function (lexical less or equal) Lexically compare the order of two character sequences being less or equal. Description The left-hand side, the right-hand side or both character sequences can\nbe represented by a string type.\nThis defines three procedures overloading the intrinsic lle procedure. Syntax res = lle (lhs, rhs) Status Experimental Class Elemental function. Argument lhs : Either scalar character value or string type. This argument is intent(in) . rhs : Either scalar character value or string type. This argument is intent(in) . Result value The result is a default logical scalar value. Example use stdlib_string_type implicit none type ( string_type ) :: string logical :: res string = \"bcd\" res = lle ( string , \"abc\" ) ! res .eqv. .false. res = lle ( string , \"bcd\" ) ! res .eqv. .true. res = lle ( string , \"cde\" ) ! res .eqv. .true. end Comparison operator greater Compare the order of two character sequences being greater. Description The left-hand side, the right-hand side or both character sequences can\nbe represented by a string type.\nThis defines three procedures overloading the intrinsic operator(.gt.) . Syntax res = lhs > rhs Status Experimental Class Elemental function, operator(.gt.) . Argument lhs : Either scalar character value or string type. This argument is intent(in) . rhs : Either scalar character value or string type. This argument is intent(in) . Result value The result is a default logical scalar value. Example use stdlib_string_type implicit none type ( string_type ) :: string logical :: res string = \"bcd\" res = string > \"abc\" ! res .eqv. .true. res = string > \"bcd\" ! res .eqv. .false. res = string > \"cde\" ! res .eqv. .false. end Comparison operator less Compare the order of two character sequences being less. Description The left-hand side, the right-hand side or both character sequences can\nbe represented by a string type.\nThis defines three procedures overloading the intrinsic operator(.lt.) . Syntax res = lhs < rhs Status Experimental Class Elemental function, operator(.lt.) . Argument lhs : Either scalar character value or string type. This argument is intent(in) . rhs : Either scalar character value or string type. This argument is intent(in) . Result value The result is a default logical scalar value. Example use stdlib_string_type implicit none type ( string_type ) :: string logical :: res string = \"bcd\" res = string < \"abc\" ! res .eqv. .false. res = string < \"bcd\" ! res .eqv. .false. res = string < \"cde\" ! res .eqv. .true. end Comparison operator greater or equal Compare the order of two character sequences being greater or equal. Description The left-hand side, the right-hand side or both character sequences can\nbe represented by a string type.\nThis defines three procedures overloading the intrinsic operator(.ge.) . Syntax res = lhs >= rhs Status Experimental Class Elemental function, operator(.ge.) . Argument lhs : Either scalar character value or string type. This argument is intent(in) . rhs : Either scalar character value or string type. This argument is intent(in) . Result value The result is a default logical scalar value. Example use stdlib_string_type implicit none type ( string_type ) :: string logical :: res string = \"bcd\" res = string >= \"abc\" ! res .eqv. .true. res = string >= \"bcd\" ! res .eqv. .true. res = string >= \"cde\" ! res .eqv. .false. end Comparison operator less or equal Compare the order of two character sequences being less or equal. Description The left-hand side, the right-hand side or both character sequences can\nbe represented by a string type.\nThis defines three procedures overloading the intrinsic operator(.le.) . Syntax res = lhs <= rhs Status Experimental Class Elemental function, operator(.le.) . Argument lhs : Either scalar character value or string type. This argument is intent(in) . rhs : Either scalar character value or string type. This argument is intent(in) . Result value The result is a default logical scalar value. Example use stdlib_string_type implicit none type ( string_type ) :: string logical :: res string = \"bcd\" res = string <= \"abc\" ! res .eqv. .false. res = string <= \"bcd\" ! res .eqv. .true. res = string <= \"cde\" ! res .eqv. .true. end Comparison operator equal Compare two character sequences for equality. Description The left-hand side, the right-hand side or both character sequences can\nbe represented by a string type.\nThis defines three procedures overloading the intrinsic operator(.eq.) . Syntax res = lhs == rhs Status Experimental Class Elemental function, operator(.eq.) . Argument lhs : Either scalar character value or string type. This argument is intent(in) . rhs : Either scalar character value or string type. This argument is intent(in) . Result value The result is a default logical scalar value. Example use stdlib_string_type implicit none type ( string_type ) :: string logical :: res string = \"bcd\" res = string == \"abc\" ! res .eqv. .false. res = string == \"bcd\" ! res .eqv. .true. res = string == \"cde\" ! res .eqv. .false. end Comparison operator not equal Compare two character sequences for inequality. Description The left-hand side, the right-hand side or both character sequences can\nbe represented by a string type.\nThis defines three procedures overloading the intrinsic operator(.ne.) . Syntax res = lhs /= rhs Status Experimental Class Elemental function, operator(.ne.) . Argument lhs : Either scalar character value or string type. This argument is intent(in) . rhs : Either scalar character value or string type. This argument is intent(in) . Result value The result is a default logical scalar value. Example use stdlib_string_type implicit none type ( string_type ) :: string logical :: res string = \"bcd\" res = string /= \"abc\" ! res .eqv. .true. res = string /= \"bcd\" ! res .eqv. .false. res = string /= \"cde\" ! res .eqv. .true. end Concatenation operator Concatenate two character sequences. Description The left-hand side, the right-hand side or both character sequences can\nbe represented by a string type.\nThis defines three procedures overloading the intrinsic operator(//) . Syntax res = lhs // rhs Status Experimental Class Elemental function, operator(//) . Argument lhs : Either scalar character value or string type. This argument is intent(in) . rhs : Either scalar character value or string type. This argument is intent(in) . Result value The result is a scalar character value. Example use stdlib_string_type implicit none type ( string_type ) :: string string = \"Hello, \" string = string // \"World!\" ! dlc(string) == 13 end Unformatted write Description Write the character sequence hold by the string to a connected unformatted unit.\nThe character sequences is represented by an 64 bit signed integer record,\nholding the length of the following character record. Syntax write(unit, iostat=iostat, iomsg=iomsg) string Status Experimental Class Unformatted derived type IO. Argument string : Instance of the string type to read. This argument is intent(inout) . unit : Formatted unit for output. This argument is intent(in) . iostat : Status identifier to indicate success of output operation.\n  This argument is intent(out) . iomsg : Buffer to return error message in case of failing output operation.\n  This argument is intent(inout) . Example use stdlib_string_type implicit none type ( string_type ) :: string integer :: io string = \"Important saved value\" open ( newunit = io , form = \"unformatted\" , status = \"scratch\" ) write ( io ) string rewind ( io ) read ( io ) string close ( io ) end Formatted write Description Write the character sequence hold by the string to a connected formatted unit. Syntax write(unit, fmt, iostat=iostat, iomsg=iomsg) string Status Experimental Class Formatted derived type IO. Argument string : Instance of the string type to read. This argument is intent(inout) . unit : Formatted unit for output. This argument is intent(in) . iotype : Type of formatted data transfer, has the value \"LISTDIRECTED\" for fmt=* , \"NAMELIST\" for namelist output or starts with \"DT\" for derived type output.\n  This argument is intent(in) . v_list : Rank one array of default integer type containing the edit descriptors for\n  derived type output.\n  This argument is intent(in) . iostat : Status identifier to indicate success of output operation.\n  This argument is intent(out) . iomsg : Buffer to return error message in case of failing output operation.\n  This argument is intent(inout) . Example use stdlib_string_type implicit none type ( string_type ) :: string integer :: io string = \"Important saved value\" open ( newunit = io , form = \"formatted\" , status = \"scratch\" ) write ( io , * ) string write ( io , * ) rewind ( io ) read ( io , * ) string close ( io ) end Unformatted read Description Read a character sequence from a connected unformatted unit into the string.\nThe character sequences is represented by an 64 bit signed integer record,\nholding the length of the following character record. Syntax read(unit, iostat=iostat, iomsg=iomsg) string Status Experimental Class Unformatted derived type IO. Argument string : Instance of the string type to read. This argument is intent(inout) . unit : Formatted unit for input. This argument is intent(in) . iostat : Status identifier to indicate success of input operation.\n  This argument is intent(out) . iomsg : Buffer to return error message in case of failing input operation.\n  This argument is intent(inout) . Example use stdlib_string_type implicit none type ( string_type ) :: string integer :: io string = \"Important saved value\" open ( newunit = io , form = \"unformatted\" , status = \"scratch\" ) write ( io ) string rewind ( io ) read ( io ) string close ( io ) end Formatted read Description Read a character sequence from a connected formatted unit into the string. Syntax read(unit, fmt, iostat=iostat, iomsg=iomsg) string Status Experimental Class Formatted derived type IO. Argument string : Instance of the string type to read. This argument is intent(inout) . unit : Formatted unit for input. This argument is intent(in) . iotype : Type of formatted data transfer, has the value \"LISTDIRECTED\" for fmt=* , \"NAMELIST\" for namelist input or starts with \"DT\" for derived type input.\n  This argument is intent(in) . v_list : Rank one array of default integer type containing the edit descriptors for\n  derived type input.\n  This argument is intent(in) . iostat : Status identifier to indicate success of input operation.\n  This argument is intent(out) . iomsg : Buffer to return error message in case of failing input operation.\n  This argument is intent(inout) . Example use stdlib_string_type implicit none type ( string_type ) :: string integer :: io string = \"Important saved value\" open ( newunit = io , form = \"formatted\" , status = \"scratch\" ) write ( io , * ) string write ( io , * ) rewind ( io ) read ( io , * ) string close ( io ) end","tags":"","loc":"page/specs/stdlib_string_type.html"}]}